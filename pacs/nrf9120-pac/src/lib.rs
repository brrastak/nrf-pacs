#![doc = "Peripheral access API for NRF9120 microcontrollers (generated using svd2rust v0.33.2 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.33.2/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 3;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn SPU();
    fn CLOCK_POWER();
    fn SPIM0_SPIS0_TWIM0_TWIS0_UARTE0();
    fn SPIM1_SPIS1_TWIM1_TWIS1_UARTE1();
    fn SPIM2_SPIS2_TWIM2_TWIS2_UARTE2();
    fn SPIM3_SPIS3_TWIM3_TWIS3_UARTE3();
    fn GPIOTE0();
    fn SAADC();
    fn TIMER0();
    fn TIMER1();
    fn TIMER2();
    fn RTC0();
    fn RTC1();
    fn WDT();
    fn EGU0();
    fn EGU1();
    fn EGU2();
    fn EGU3();
    fn EGU4();
    fn EGU5();
    fn PWM0();
    fn PWM1();
    fn PWM2();
    fn PWM3();
    fn PDM();
    fn I2S();
    fn IPC();
    fn FPU();
    fn GPIOTE1();
    fn KMU();
    fn CRYPTOCELL();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 65] = [
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: SPU },
    Vector { _reserved: 0 },
    Vector {
        _handler: CLOCK_POWER,
    },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector {
        _handler: SPIM0_SPIS0_TWIM0_TWIS0_UARTE0,
    },
    Vector {
        _handler: SPIM1_SPIS1_TWIM1_TWIS1_UARTE1,
    },
    Vector {
        _handler: SPIM2_SPIS2_TWIM2_TWIS2_UARTE2,
    },
    Vector {
        _handler: SPIM3_SPIS3_TWIM3_TWIS3_UARTE3,
    },
    Vector { _reserved: 0 },
    Vector { _handler: GPIOTE0 },
    Vector { _handler: SAADC },
    Vector { _handler: TIMER0 },
    Vector { _handler: TIMER1 },
    Vector { _handler: TIMER2 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: RTC0 },
    Vector { _handler: RTC1 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: WDT },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: EGU0 },
    Vector { _handler: EGU1 },
    Vector { _handler: EGU2 },
    Vector { _handler: EGU3 },
    Vector { _handler: EGU4 },
    Vector { _handler: EGU5 },
    Vector { _handler: PWM0 },
    Vector { _handler: PWM1 },
    Vector { _handler: PWM2 },
    Vector { _handler: PWM3 },
    Vector { _reserved: 0 },
    Vector { _handler: PDM },
    Vector { _reserved: 0 },
    Vector { _handler: I2S },
    Vector { _reserved: 0 },
    Vector { _handler: IPC },
    Vector { _reserved: 0 },
    Vector { _handler: FPU },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: GPIOTE1 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: KMU },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector {
        _handler: CRYPTOCELL,
    },
];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "3 - SPU"]
    SPU = 3,
    #[doc = "5 - CLOCK_POWER"]
    CLOCK_POWER = 5,
    #[doc = "8 - SPIM0_SPIS0_TWIM0_TWIS0_UARTE0"]
    SPIM0_SPIS0_TWIM0_TWIS0_UARTE0 = 8,
    #[doc = "9 - SPIM1_SPIS1_TWIM1_TWIS1_UARTE1"]
    SPIM1_SPIS1_TWIM1_TWIS1_UARTE1 = 9,
    #[doc = "10 - SPIM2_SPIS2_TWIM2_TWIS2_UARTE2"]
    SPIM2_SPIS2_TWIM2_TWIS2_UARTE2 = 10,
    #[doc = "11 - SPIM3_SPIS3_TWIM3_TWIS3_UARTE3"]
    SPIM3_SPIS3_TWIM3_TWIS3_UARTE3 = 11,
    #[doc = "13 - GPIOTE0"]
    GPIOTE0 = 13,
    #[doc = "14 - SAADC"]
    SAADC = 14,
    #[doc = "15 - TIMER0"]
    TIMER0 = 15,
    #[doc = "16 - TIMER1"]
    TIMER1 = 16,
    #[doc = "17 - TIMER2"]
    TIMER2 = 17,
    #[doc = "20 - RTC0"]
    RTC0 = 20,
    #[doc = "21 - RTC1"]
    RTC1 = 21,
    #[doc = "24 - WDT"]
    WDT = 24,
    #[doc = "27 - EGU0"]
    EGU0 = 27,
    #[doc = "28 - EGU1"]
    EGU1 = 28,
    #[doc = "29 - EGU2"]
    EGU2 = 29,
    #[doc = "30 - EGU3"]
    EGU3 = 30,
    #[doc = "31 - EGU4"]
    EGU4 = 31,
    #[doc = "32 - EGU5"]
    EGU5 = 32,
    #[doc = "33 - PWM0"]
    PWM0 = 33,
    #[doc = "34 - PWM1"]
    PWM1 = 34,
    #[doc = "35 - PWM2"]
    PWM2 = 35,
    #[doc = "36 - PWM3"]
    PWM3 = 36,
    #[doc = "38 - PDM"]
    PDM = 38,
    #[doc = "40 - I2S"]
    I2S = 40,
    #[doc = "42 - IPC"]
    IPC = 42,
    #[doc = "44 - FPU"]
    FPU = 44,
    #[doc = "49 - GPIOTE1"]
    GPIOTE1 = 49,
    #[doc = "57 - KMU"]
    KMU = 57,
    #[doc = "64 - CRYPTOCELL"]
    CRYPTOCELL = 64,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[doc = "Factory Information Configuration Registers"]
pub struct FicrS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FicrS {}
impl FicrS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ficr_s::RegisterBlock = 0x00ff_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ficr_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for FicrS {
    type Target = ficr_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FicrS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FicrS").finish()
    }
}
#[doc = "Factory Information Configuration Registers"]
pub mod ficr_s;
#[doc = "User information configuration registers User information configuration registers"]
pub struct UicrS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UicrS {}
impl UicrS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uicr_s::RegisterBlock = 0x00ff_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uicr_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for UicrS {
    type Target = uicr_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UicrS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UicrS").finish()
    }
}
#[doc = "User information configuration registers User information configuration registers"]
pub mod uicr_s;
#[doc = "Trace and debug control"]
pub struct TadS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TadS {}
impl TadS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tad_s::RegisterBlock = 0xe008_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tad_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TadS {
    type Target = tad_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TadS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TadS").finish()
    }
}
#[doc = "Trace and debug control"]
pub mod tad_s;
#[doc = "System protection unit"]
pub struct SpuS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SpuS {}
impl SpuS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spu_s::RegisterBlock = 0x5000_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spu_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SpuS {
    type Target = spu_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SpuS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SpuS").finish()
    }
}
#[doc = "System protection unit"]
pub mod spu_s;
#[doc = "Voltage regulators control 0"]
pub struct RegulatorsNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RegulatorsNs {}
impl RegulatorsNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const regulators_ns::RegisterBlock = 0x4000_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const regulators_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for RegulatorsNs {
    type Target = regulators_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RegulatorsNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RegulatorsNs").finish()
    }
}
#[doc = "Voltage regulators control 0"]
pub mod regulators_ns;
#[doc = "Voltage regulators control 1"]
pub struct RegulatorsS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RegulatorsS {}
impl RegulatorsS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const regulators_ns::RegisterBlock = 0x5000_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const regulators_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for RegulatorsS {
    type Target = regulators_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RegulatorsS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RegulatorsS").finish()
    }
}
#[doc = "Voltage regulators control 1"]
pub use self::regulators_ns as regulators_s;
#[doc = "Clock management 0"]
pub struct ClockNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ClockNs {}
impl ClockNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const clock_ns::RegisterBlock = 0x4000_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const clock_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ClockNs {
    type Target = clock_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ClockNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ClockNs").finish()
    }
}
#[doc = "Clock management 0"]
pub mod clock_ns;
#[doc = "Power control 0"]
pub struct PowerNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PowerNs {}
impl PowerNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const power_ns::RegisterBlock = 0x4000_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const power_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PowerNs {
    type Target = power_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PowerNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PowerNs").finish()
    }
}
#[doc = "Power control 0"]
pub mod power_ns;
#[doc = "Clock management 1"]
pub struct ClockS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ClockS {}
impl ClockS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const clock_ns::RegisterBlock = 0x5000_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const clock_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ClockS {
    type Target = clock_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ClockS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ClockS").finish()
    }
}
#[doc = "Clock management 1"]
pub use self::clock_ns as clock_s;
#[doc = "Power control 1"]
pub struct PowerS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PowerS {}
impl PowerS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const power_ns::RegisterBlock = 0x5000_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const power_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PowerS {
    type Target = power_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PowerS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PowerS").finish()
    }
}
#[doc = "Power control 1"]
pub use self::power_ns as power_s;
#[doc = "Control access port"]
pub struct CtrlApPeriS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CtrlApPeriS {}
impl CtrlApPeriS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ctrl_ap_peri_s::RegisterBlock = 0x5000_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ctrl_ap_peri_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CtrlApPeriS {
    type Target = ctrl_ap_peri_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CtrlApPeriS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CtrlApPeriS").finish()
    }
}
#[doc = "Control access port"]
pub mod ctrl_ap_peri_s;
#[doc = "Serial Peripheral Interface Master with EasyDMA 0"]
pub struct Spim0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spim0Ns {}
impl Spim0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spim0_ns::RegisterBlock = 0x4000_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spim0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spim0Ns {
    type Target = spim0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spim0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spim0Ns").finish()
    }
}
#[doc = "Serial Peripheral Interface Master with EasyDMA 0"]
pub mod spim0_ns;
#[doc = "SPI Slave 0"]
pub struct Spis0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spis0Ns {}
impl Spis0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spis0_ns::RegisterBlock = 0x4000_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spis0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spis0Ns {
    type Target = spis0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spis0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spis0Ns").finish()
    }
}
#[doc = "SPI Slave 0"]
pub mod spis0_ns;
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 0"]
pub struct Twim0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Twim0Ns {}
impl Twim0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const twim0_ns::RegisterBlock = 0x4000_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const twim0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Twim0Ns {
    type Target = twim0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Twim0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Twim0Ns").finish()
    }
}
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 0"]
pub mod twim0_ns;
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 0"]
pub struct Twis0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Twis0Ns {}
impl Twis0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const twis0_ns::RegisterBlock = 0x4000_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const twis0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Twis0Ns {
    type Target = twis0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Twis0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Twis0Ns").finish()
    }
}
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 0"]
pub mod twis0_ns;
#[doc = "UART with EasyDMA 0"]
pub struct Uarte0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uarte0Ns {}
impl Uarte0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uarte0_ns::RegisterBlock = 0x4000_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uarte0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uarte0Ns {
    type Target = uarte0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uarte0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uarte0Ns").finish()
    }
}
#[doc = "UART with EasyDMA 0"]
pub mod uarte0_ns;
#[doc = "Serial Peripheral Interface Master with EasyDMA 1"]
pub struct Spim0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spim0S {}
impl Spim0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spim0_ns::RegisterBlock = 0x5000_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spim0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spim0S {
    type Target = spim0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spim0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spim0S").finish()
    }
}
#[doc = "Serial Peripheral Interface Master with EasyDMA 1"]
pub use self::spim0_ns as spim0_s;
#[doc = "SPI Slave 1"]
pub struct Spis0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spis0S {}
impl Spis0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spis0_ns::RegisterBlock = 0x5000_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spis0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spis0S {
    type Target = spis0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spis0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spis0S").finish()
    }
}
#[doc = "SPI Slave 1"]
pub use self::spis0_ns as spis0_s;
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 1"]
pub struct Twim0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Twim0S {}
impl Twim0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const twim0_ns::RegisterBlock = 0x5000_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const twim0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Twim0S {
    type Target = twim0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Twim0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Twim0S").finish()
    }
}
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 1"]
pub use self::twim0_ns as twim0_s;
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 1"]
pub struct Twis0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Twis0S {}
impl Twis0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const twis0_ns::RegisterBlock = 0x5000_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const twis0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Twis0S {
    type Target = twis0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Twis0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Twis0S").finish()
    }
}
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 1"]
pub use self::twis0_ns as twis0_s;
#[doc = "UART with EasyDMA 1"]
pub struct Uarte0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uarte0S {}
impl Uarte0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uarte0_ns::RegisterBlock = 0x5000_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uarte0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uarte0S {
    type Target = uarte0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uarte0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uarte0S").finish()
    }
}
#[doc = "UART with EasyDMA 1"]
pub use self::uarte0_ns as uarte0_s;
#[doc = "Serial Peripheral Interface Master with EasyDMA 2"]
pub struct Spim1Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spim1Ns {}
impl Spim1Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spim0_ns::RegisterBlock = 0x4000_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spim0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spim1Ns {
    type Target = spim0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spim1Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spim1Ns").finish()
    }
}
#[doc = "Serial Peripheral Interface Master with EasyDMA 2"]
pub use self::spim0_ns as spim1_ns;
#[doc = "SPI Slave 2"]
pub struct Spis1Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spis1Ns {}
impl Spis1Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spis0_ns::RegisterBlock = 0x4000_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spis0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spis1Ns {
    type Target = spis0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spis1Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spis1Ns").finish()
    }
}
#[doc = "SPI Slave 2"]
pub use self::spis0_ns as spis1_ns;
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 2"]
pub struct Twim1Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Twim1Ns {}
impl Twim1Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const twim0_ns::RegisterBlock = 0x4000_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const twim0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Twim1Ns {
    type Target = twim0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Twim1Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Twim1Ns").finish()
    }
}
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 2"]
pub use self::twim0_ns as twim1_ns;
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 2"]
pub struct Twis1Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Twis1Ns {}
impl Twis1Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const twis0_ns::RegisterBlock = 0x4000_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const twis0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Twis1Ns {
    type Target = twis0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Twis1Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Twis1Ns").finish()
    }
}
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 2"]
pub use self::twis0_ns as twis1_ns;
#[doc = "UART with EasyDMA 2"]
pub struct Uarte1Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uarte1Ns {}
impl Uarte1Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uarte0_ns::RegisterBlock = 0x4000_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uarte0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uarte1Ns {
    type Target = uarte0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uarte1Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uarte1Ns").finish()
    }
}
#[doc = "UART with EasyDMA 2"]
pub use self::uarte0_ns as uarte1_ns;
#[doc = "Serial Peripheral Interface Master with EasyDMA 3"]
pub struct Spim1S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spim1S {}
impl Spim1S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spim0_ns::RegisterBlock = 0x5000_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spim0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spim1S {
    type Target = spim0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spim1S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spim1S").finish()
    }
}
#[doc = "Serial Peripheral Interface Master with EasyDMA 3"]
pub use self::spim0_ns as spim1_s;
#[doc = "SPI Slave 3"]
pub struct Spis1S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spis1S {}
impl Spis1S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spis0_ns::RegisterBlock = 0x5000_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spis0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spis1S {
    type Target = spis0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spis1S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spis1S").finish()
    }
}
#[doc = "SPI Slave 3"]
pub use self::spis0_ns as spis1_s;
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 3"]
pub struct Twim1S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Twim1S {}
impl Twim1S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const twim0_ns::RegisterBlock = 0x5000_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const twim0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Twim1S {
    type Target = twim0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Twim1S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Twim1S").finish()
    }
}
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 3"]
pub use self::twim0_ns as twim1_s;
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 3"]
pub struct Twis1S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Twis1S {}
impl Twis1S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const twis0_ns::RegisterBlock = 0x5000_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const twis0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Twis1S {
    type Target = twis0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Twis1S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Twis1S").finish()
    }
}
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 3"]
pub use self::twis0_ns as twis1_s;
#[doc = "UART with EasyDMA 3"]
pub struct Uarte1S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uarte1S {}
impl Uarte1S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uarte0_ns::RegisterBlock = 0x5000_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uarte0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uarte1S {
    type Target = uarte0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uarte1S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uarte1S").finish()
    }
}
#[doc = "UART with EasyDMA 3"]
pub use self::uarte0_ns as uarte1_s;
#[doc = "Serial Peripheral Interface Master with EasyDMA 4"]
pub struct Spim2Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spim2Ns {}
impl Spim2Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spim0_ns::RegisterBlock = 0x4000_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spim0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spim2Ns {
    type Target = spim0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spim2Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spim2Ns").finish()
    }
}
#[doc = "Serial Peripheral Interface Master with EasyDMA 4"]
pub use self::spim0_ns as spim2_ns;
#[doc = "SPI Slave 4"]
pub struct Spis2Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spis2Ns {}
impl Spis2Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spis0_ns::RegisterBlock = 0x4000_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spis0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spis2Ns {
    type Target = spis0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spis2Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spis2Ns").finish()
    }
}
#[doc = "SPI Slave 4"]
pub use self::spis0_ns as spis2_ns;
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 4"]
pub struct Twim2Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Twim2Ns {}
impl Twim2Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const twim0_ns::RegisterBlock = 0x4000_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const twim0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Twim2Ns {
    type Target = twim0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Twim2Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Twim2Ns").finish()
    }
}
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 4"]
pub use self::twim0_ns as twim2_ns;
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 4"]
pub struct Twis2Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Twis2Ns {}
impl Twis2Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const twis0_ns::RegisterBlock = 0x4000_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const twis0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Twis2Ns {
    type Target = twis0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Twis2Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Twis2Ns").finish()
    }
}
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 4"]
pub use self::twis0_ns as twis2_ns;
#[doc = "UART with EasyDMA 4"]
pub struct Uarte2Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uarte2Ns {}
impl Uarte2Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uarte0_ns::RegisterBlock = 0x4000_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uarte0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uarte2Ns {
    type Target = uarte0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uarte2Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uarte2Ns").finish()
    }
}
#[doc = "UART with EasyDMA 4"]
pub use self::uarte0_ns as uarte2_ns;
#[doc = "Serial Peripheral Interface Master with EasyDMA 5"]
pub struct Spim2S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spim2S {}
impl Spim2S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spim0_ns::RegisterBlock = 0x5000_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spim0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spim2S {
    type Target = spim0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spim2S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spim2S").finish()
    }
}
#[doc = "Serial Peripheral Interface Master with EasyDMA 5"]
pub use self::spim0_ns as spim2_s;
#[doc = "SPI Slave 5"]
pub struct Spis2S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spis2S {}
impl Spis2S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spis0_ns::RegisterBlock = 0x5000_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spis0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spis2S {
    type Target = spis0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spis2S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spis2S").finish()
    }
}
#[doc = "SPI Slave 5"]
pub use self::spis0_ns as spis2_s;
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 5"]
pub struct Twim2S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Twim2S {}
impl Twim2S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const twim0_ns::RegisterBlock = 0x5000_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const twim0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Twim2S {
    type Target = twim0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Twim2S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Twim2S").finish()
    }
}
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 5"]
pub use self::twim0_ns as twim2_s;
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 5"]
pub struct Twis2S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Twis2S {}
impl Twis2S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const twis0_ns::RegisterBlock = 0x5000_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const twis0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Twis2S {
    type Target = twis0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Twis2S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Twis2S").finish()
    }
}
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 5"]
pub use self::twis0_ns as twis2_s;
#[doc = "UART with EasyDMA 5"]
pub struct Uarte2S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uarte2S {}
impl Uarte2S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uarte0_ns::RegisterBlock = 0x5000_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uarte0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uarte2S {
    type Target = uarte0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uarte2S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uarte2S").finish()
    }
}
#[doc = "UART with EasyDMA 5"]
pub use self::uarte0_ns as uarte2_s;
#[doc = "Serial Peripheral Interface Master with EasyDMA 6"]
pub struct Spim3Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spim3Ns {}
impl Spim3Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spim0_ns::RegisterBlock = 0x4000_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spim0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spim3Ns {
    type Target = spim0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spim3Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spim3Ns").finish()
    }
}
#[doc = "Serial Peripheral Interface Master with EasyDMA 6"]
pub use self::spim0_ns as spim3_ns;
#[doc = "SPI Slave 6"]
pub struct Spis3Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spis3Ns {}
impl Spis3Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spis0_ns::RegisterBlock = 0x4000_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spis0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spis3Ns {
    type Target = spis0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spis3Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spis3Ns").finish()
    }
}
#[doc = "SPI Slave 6"]
pub use self::spis0_ns as spis3_ns;
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 6"]
pub struct Twim3Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Twim3Ns {}
impl Twim3Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const twim0_ns::RegisterBlock = 0x4000_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const twim0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Twim3Ns {
    type Target = twim0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Twim3Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Twim3Ns").finish()
    }
}
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 6"]
pub use self::twim0_ns as twim3_ns;
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 6"]
pub struct Twis3Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Twis3Ns {}
impl Twis3Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const twis0_ns::RegisterBlock = 0x4000_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const twis0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Twis3Ns {
    type Target = twis0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Twis3Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Twis3Ns").finish()
    }
}
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 6"]
pub use self::twis0_ns as twis3_ns;
#[doc = "UART with EasyDMA 6"]
pub struct Uarte3Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uarte3Ns {}
impl Uarte3Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uarte0_ns::RegisterBlock = 0x4000_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uarte0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uarte3Ns {
    type Target = uarte0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uarte3Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uarte3Ns").finish()
    }
}
#[doc = "UART with EasyDMA 6"]
pub use self::uarte0_ns as uarte3_ns;
#[doc = "Serial Peripheral Interface Master with EasyDMA 7"]
pub struct Spim3S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spim3S {}
impl Spim3S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spim0_ns::RegisterBlock = 0x5000_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spim0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spim3S {
    type Target = spim0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spim3S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spim3S").finish()
    }
}
#[doc = "Serial Peripheral Interface Master with EasyDMA 7"]
pub use self::spim0_ns as spim3_s;
#[doc = "SPI Slave 7"]
pub struct Spis3S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spis3S {}
impl Spis3S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spis0_ns::RegisterBlock = 0x5000_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spis0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spis3S {
    type Target = spis0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spis3S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spis3S").finish()
    }
}
#[doc = "SPI Slave 7"]
pub use self::spis0_ns as spis3_s;
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 7"]
pub struct Twim3S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Twim3S {}
impl Twim3S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const twim0_ns::RegisterBlock = 0x5000_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const twim0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Twim3S {
    type Target = twim0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Twim3S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Twim3S").finish()
    }
}
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 7"]
pub use self::twim0_ns as twim3_s;
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 7"]
pub struct Twis3S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Twis3S {}
impl Twis3S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const twis0_ns::RegisterBlock = 0x5000_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const twis0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Twis3S {
    type Target = twis0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Twis3S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Twis3S").finish()
    }
}
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 7"]
pub use self::twis0_ns as twis3_s;
#[doc = "UART with EasyDMA 7"]
pub struct Uarte3S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Uarte3S {}
impl Uarte3S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uarte0_ns::RegisterBlock = 0x5000_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uarte0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Uarte3S {
    type Target = uarte0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Uarte3S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uarte3S").finish()
    }
}
#[doc = "UART with EasyDMA 7"]
pub use self::uarte0_ns as uarte3_s;
#[doc = "GPIO Tasks and Events 0"]
pub struct Gpiote0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpiote0S {}
impl Gpiote0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpiote0_s::RegisterBlock = 0x5000_d000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpiote0_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpiote0S {
    type Target = gpiote0_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpiote0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpiote0S").finish()
    }
}
#[doc = "GPIO Tasks and Events 0"]
pub mod gpiote0_s;
#[doc = "Analog to Digital Converter 0"]
pub struct SaadcNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SaadcNs {}
impl SaadcNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const saadc_ns::RegisterBlock = 0x4000_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const saadc_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SaadcNs {
    type Target = saadc_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SaadcNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SaadcNs").finish()
    }
}
#[doc = "Analog to Digital Converter 0"]
pub mod saadc_ns;
#[doc = "Analog to Digital Converter 1"]
pub struct SaadcS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SaadcS {}
impl SaadcS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const saadc_ns::RegisterBlock = 0x5000_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const saadc_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for SaadcS {
    type Target = saadc_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SaadcS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SaadcS").finish()
    }
}
#[doc = "Analog to Digital Converter 1"]
pub use self::saadc_ns as saadc_s;
#[doc = "Timer/Counter 0"]
pub struct Timer0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer0Ns {}
impl Timer0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer0_ns::RegisterBlock = 0x4000_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer0Ns {
    type Target = timer0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer0Ns").finish()
    }
}
#[doc = "Timer/Counter 0"]
pub mod timer0_ns;
#[doc = "Timer/Counter 1"]
pub struct Timer0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer0S {}
impl Timer0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer0_ns::RegisterBlock = 0x5000_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer0S {
    type Target = timer0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer0S").finish()
    }
}
#[doc = "Timer/Counter 1"]
pub use self::timer0_ns as timer0_s;
#[doc = "Timer/Counter 2"]
pub struct Timer1Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer1Ns {}
impl Timer1Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer0_ns::RegisterBlock = 0x4001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer1Ns {
    type Target = timer0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer1Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer1Ns").finish()
    }
}
#[doc = "Timer/Counter 2"]
pub use self::timer0_ns as timer1_ns;
#[doc = "Timer/Counter 3"]
pub struct Timer1S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer1S {}
impl Timer1S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer0_ns::RegisterBlock = 0x5001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer1S {
    type Target = timer0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer1S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer1S").finish()
    }
}
#[doc = "Timer/Counter 3"]
pub use self::timer0_ns as timer1_s;
#[doc = "Timer/Counter 4"]
pub struct Timer2Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer2Ns {}
impl Timer2Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer0_ns::RegisterBlock = 0x4001_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer2Ns {
    type Target = timer0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer2Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer2Ns").finish()
    }
}
#[doc = "Timer/Counter 4"]
pub use self::timer0_ns as timer2_ns;
#[doc = "Timer/Counter 5"]
pub struct Timer2S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Timer2S {}
impl Timer2S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const timer0_ns::RegisterBlock = 0x5001_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Timer2S {
    type Target = timer0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Timer2S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer2S").finish()
    }
}
#[doc = "Timer/Counter 5"]
pub use self::timer0_ns as timer2_s;
#[doc = "Real-time counter 0"]
pub struct Rtc0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rtc0Ns {}
impl Rtc0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rtc0_ns::RegisterBlock = 0x4001_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rtc0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rtc0Ns {
    type Target = rtc0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rtc0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rtc0Ns").finish()
    }
}
#[doc = "Real-time counter 0"]
pub mod rtc0_ns;
#[doc = "Real-time counter 1"]
pub struct Rtc0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rtc0S {}
impl Rtc0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rtc0_ns::RegisterBlock = 0x5001_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rtc0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rtc0S {
    type Target = rtc0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rtc0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rtc0S").finish()
    }
}
#[doc = "Real-time counter 1"]
pub use self::rtc0_ns as rtc0_s;
#[doc = "Real-time counter 2"]
pub struct Rtc1Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rtc1Ns {}
impl Rtc1Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rtc0_ns::RegisterBlock = 0x4001_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rtc0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rtc1Ns {
    type Target = rtc0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rtc1Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rtc1Ns").finish()
    }
}
#[doc = "Real-time counter 2"]
pub use self::rtc0_ns as rtc1_ns;
#[doc = "Real-time counter 3"]
pub struct Rtc1S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Rtc1S {}
impl Rtc1S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rtc0_ns::RegisterBlock = 0x5001_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rtc0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Rtc1S {
    type Target = rtc0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Rtc1S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rtc1S").finish()
    }
}
#[doc = "Real-time counter 3"]
pub use self::rtc0_ns as rtc1_s;
#[doc = "Distributed programmable peripheral interconnect controller 0"]
pub struct DppicNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DppicNs {}
impl DppicNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dppic_ns::RegisterBlock = 0x4001_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dppic_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DppicNs {
    type Target = dppic_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DppicNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DppicNs").finish()
    }
}
#[doc = "Distributed programmable peripheral interconnect controller 0"]
pub mod dppic_ns;
#[doc = "Distributed programmable peripheral interconnect controller 1"]
pub struct DppicS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DppicS {}
impl DppicS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dppic_ns::RegisterBlock = 0x5001_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dppic_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for DppicS {
    type Target = dppic_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DppicS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DppicS").finish()
    }
}
#[doc = "Distributed programmable peripheral interconnect controller 1"]
pub use self::dppic_ns as dppic_s;
#[doc = "Watchdog Timer 0"]
pub struct WdtNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WdtNs {}
impl WdtNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdt_ns::RegisterBlock = 0x4001_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdt_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for WdtNs {
    type Target = wdt_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for WdtNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WdtNs").finish()
    }
}
#[doc = "Watchdog Timer 0"]
pub mod wdt_ns;
#[doc = "Watchdog Timer 1"]
pub struct WdtS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WdtS {}
impl WdtS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wdt_ns::RegisterBlock = 0x5001_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdt_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for WdtS {
    type Target = wdt_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for WdtS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WdtS").finish()
    }
}
#[doc = "Watchdog Timer 1"]
pub use self::wdt_ns as wdt_s;
#[doc = "Event generator unit 0"]
pub struct Egu0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Egu0Ns {}
impl Egu0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const egu0_ns::RegisterBlock = 0x4001_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const egu0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Egu0Ns {
    type Target = egu0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Egu0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Egu0Ns").finish()
    }
}
#[doc = "Event generator unit 0"]
pub mod egu0_ns;
#[doc = "Event generator unit 1"]
pub struct Egu0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Egu0S {}
impl Egu0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const egu0_ns::RegisterBlock = 0x5001_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const egu0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Egu0S {
    type Target = egu0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Egu0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Egu0S").finish()
    }
}
#[doc = "Event generator unit 1"]
pub use self::egu0_ns as egu0_s;
#[doc = "Event generator unit 2"]
pub struct Egu1Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Egu1Ns {}
impl Egu1Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const egu0_ns::RegisterBlock = 0x4001_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const egu0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Egu1Ns {
    type Target = egu0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Egu1Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Egu1Ns").finish()
    }
}
#[doc = "Event generator unit 2"]
pub use self::egu0_ns as egu1_ns;
#[doc = "Event generator unit 3"]
pub struct Egu1S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Egu1S {}
impl Egu1S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const egu0_ns::RegisterBlock = 0x5001_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const egu0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Egu1S {
    type Target = egu0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Egu1S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Egu1S").finish()
    }
}
#[doc = "Event generator unit 3"]
pub use self::egu0_ns as egu1_s;
#[doc = "Event generator unit 4"]
pub struct Egu2Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Egu2Ns {}
impl Egu2Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const egu0_ns::RegisterBlock = 0x4001_d000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const egu0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Egu2Ns {
    type Target = egu0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Egu2Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Egu2Ns").finish()
    }
}
#[doc = "Event generator unit 4"]
pub use self::egu0_ns as egu2_ns;
#[doc = "Event generator unit 5"]
pub struct Egu2S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Egu2S {}
impl Egu2S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const egu0_ns::RegisterBlock = 0x5001_d000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const egu0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Egu2S {
    type Target = egu0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Egu2S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Egu2S").finish()
    }
}
#[doc = "Event generator unit 5"]
pub use self::egu0_ns as egu2_s;
#[doc = "Event generator unit 6"]
pub struct Egu3Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Egu3Ns {}
impl Egu3Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const egu0_ns::RegisterBlock = 0x4001_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const egu0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Egu3Ns {
    type Target = egu0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Egu3Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Egu3Ns").finish()
    }
}
#[doc = "Event generator unit 6"]
pub use self::egu0_ns as egu3_ns;
#[doc = "Event generator unit 7"]
pub struct Egu3S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Egu3S {}
impl Egu3S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const egu0_ns::RegisterBlock = 0x5001_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const egu0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Egu3S {
    type Target = egu0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Egu3S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Egu3S").finish()
    }
}
#[doc = "Event generator unit 7"]
pub use self::egu0_ns as egu3_s;
#[doc = "Event generator unit 8"]
pub struct Egu4Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Egu4Ns {}
impl Egu4Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const egu0_ns::RegisterBlock = 0x4001_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const egu0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Egu4Ns {
    type Target = egu0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Egu4Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Egu4Ns").finish()
    }
}
#[doc = "Event generator unit 8"]
pub use self::egu0_ns as egu4_ns;
#[doc = "Event generator unit 9"]
pub struct Egu4S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Egu4S {}
impl Egu4S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const egu0_ns::RegisterBlock = 0x5001_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const egu0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Egu4S {
    type Target = egu0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Egu4S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Egu4S").finish()
    }
}
#[doc = "Event generator unit 9"]
pub use self::egu0_ns as egu4_s;
#[doc = "Event generator unit 10"]
pub struct Egu5Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Egu5Ns {}
impl Egu5Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const egu0_ns::RegisterBlock = 0x4002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const egu0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Egu5Ns {
    type Target = egu0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Egu5Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Egu5Ns").finish()
    }
}
#[doc = "Event generator unit 10"]
pub use self::egu0_ns as egu5_ns;
#[doc = "Event generator unit 11"]
pub struct Egu5S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Egu5S {}
impl Egu5S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const egu0_ns::RegisterBlock = 0x5002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const egu0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Egu5S {
    type Target = egu0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Egu5S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Egu5S").finish()
    }
}
#[doc = "Event generator unit 11"]
pub use self::egu0_ns as egu5_s;
#[doc = "Pulse width modulation unit 0"]
pub struct Pwm0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm0Ns {}
impl Pwm0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0_ns::RegisterBlock = 0x4002_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm0Ns {
    type Target = pwm0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm0Ns").finish()
    }
}
#[doc = "Pulse width modulation unit 0"]
pub mod pwm0_ns;
#[doc = "Pulse width modulation unit 1"]
pub struct Pwm0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm0S {}
impl Pwm0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0_ns::RegisterBlock = 0x5002_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm0S {
    type Target = pwm0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm0S").finish()
    }
}
#[doc = "Pulse width modulation unit 1"]
pub use self::pwm0_ns as pwm0_s;
#[doc = "Pulse width modulation unit 2"]
pub struct Pwm1Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm1Ns {}
impl Pwm1Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0_ns::RegisterBlock = 0x4002_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm1Ns {
    type Target = pwm0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm1Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm1Ns").finish()
    }
}
#[doc = "Pulse width modulation unit 2"]
pub use self::pwm0_ns as pwm1_ns;
#[doc = "Pulse width modulation unit 3"]
pub struct Pwm1S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm1S {}
impl Pwm1S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0_ns::RegisterBlock = 0x5002_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm1S {
    type Target = pwm0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm1S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm1S").finish()
    }
}
#[doc = "Pulse width modulation unit 3"]
pub use self::pwm0_ns as pwm1_s;
#[doc = "Pulse width modulation unit 4"]
pub struct Pwm2Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm2Ns {}
impl Pwm2Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0_ns::RegisterBlock = 0x4002_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm2Ns {
    type Target = pwm0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm2Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm2Ns").finish()
    }
}
#[doc = "Pulse width modulation unit 4"]
pub use self::pwm0_ns as pwm2_ns;
#[doc = "Pulse width modulation unit 5"]
pub struct Pwm2S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm2S {}
impl Pwm2S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0_ns::RegisterBlock = 0x5002_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm2S {
    type Target = pwm0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm2S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm2S").finish()
    }
}
#[doc = "Pulse width modulation unit 5"]
pub use self::pwm0_ns as pwm2_s;
#[doc = "Pulse width modulation unit 6"]
pub struct Pwm3Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm3Ns {}
impl Pwm3Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0_ns::RegisterBlock = 0x4002_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm3Ns {
    type Target = pwm0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm3Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm3Ns").finish()
    }
}
#[doc = "Pulse width modulation unit 6"]
pub use self::pwm0_ns as pwm3_ns;
#[doc = "Pulse width modulation unit 7"]
pub struct Pwm3S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm3S {}
impl Pwm3S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0_ns::RegisterBlock = 0x5002_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm3S {
    type Target = pwm0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm3S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm3S").finish()
    }
}
#[doc = "Pulse width modulation unit 7"]
pub use self::pwm0_ns as pwm3_s;
#[doc = "Pulse Density Modulation (Digital Microphone) Interface 0"]
pub struct PdmNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PdmNs {}
impl PdmNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pdm_ns::RegisterBlock = 0x4002_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pdm_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PdmNs {
    type Target = pdm_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PdmNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PdmNs").finish()
    }
}
#[doc = "Pulse Density Modulation (Digital Microphone) Interface 0"]
pub mod pdm_ns;
#[doc = "Pulse Density Modulation (Digital Microphone) Interface 1"]
pub struct PdmS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PdmS {}
impl PdmS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pdm_ns::RegisterBlock = 0x5002_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pdm_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PdmS {
    type Target = pdm_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PdmS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PdmS").finish()
    }
}
#[doc = "Pulse Density Modulation (Digital Microphone) Interface 1"]
pub use self::pdm_ns as pdm_s;
#[doc = "Inter-IC Sound 0"]
pub struct I2sNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2sNs {}
impl I2sNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2s_ns::RegisterBlock = 0x4002_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2s_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2sNs {
    type Target = i2s_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2sNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2sNs").finish()
    }
}
#[doc = "Inter-IC Sound 0"]
pub mod i2s_ns;
#[doc = "Inter-IC Sound 1"]
pub struct I2sS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2sS {}
impl I2sS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2s_ns::RegisterBlock = 0x5002_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2s_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2sS {
    type Target = i2s_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2sS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2sS").finish()
    }
}
#[doc = "Inter-IC Sound 1"]
pub use self::i2s_ns as i2s_s;
#[doc = "Interprocessor communication 0"]
pub struct IpcNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for IpcNs {}
impl IpcNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ipc_ns::RegisterBlock = 0x4002_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ipc_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for IpcNs {
    type Target = ipc_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for IpcNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("IpcNs").finish()
    }
}
#[doc = "Interprocessor communication 0"]
pub mod ipc_ns;
#[doc = "Interprocessor communication 1"]
pub struct IpcS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for IpcS {}
impl IpcS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ipc_ns::RegisterBlock = 0x5002_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ipc_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for IpcS {
    type Target = ipc_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for IpcS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("IpcS").finish()
    }
}
#[doc = "Interprocessor communication 1"]
pub use self::ipc_ns as ipc_s;
#[doc = "FPU"]
pub struct FpuNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FpuNs {}
impl FpuNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fpu_ns::RegisterBlock = 0x4002_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fpu_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for FpuNs {
    type Target = fpu_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FpuNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FpuNs").finish()
    }
}
#[doc = "FPU"]
pub mod fpu_ns;
#[doc = "GPIO Tasks and Events 1"]
pub struct Gpiote1Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpiote1Ns {}
impl Gpiote1Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpiote0_s::RegisterBlock = 0x4003_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpiote0_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpiote1Ns {
    type Target = gpiote0_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpiote1Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpiote1Ns").finish()
    }
}
#[doc = "GPIO Tasks and Events 1"]
pub use self::gpiote0_s as gpiote1_ns;
#[doc = "Access Port Protection 0"]
pub struct ApprotectNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ApprotectNs {}
impl ApprotectNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const approtect_ns::RegisterBlock = 0x4003_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const approtect_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ApprotectNs {
    type Target = approtect_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ApprotectNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ApprotectNs").finish()
    }
}
#[doc = "Access Port Protection 0"]
pub mod approtect_ns;
#[doc = "Key management unit 0"]
pub struct KmuNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for KmuNs {}
impl KmuNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const kmu_ns::RegisterBlock = 0x4003_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const kmu_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for KmuNs {
    type Target = kmu_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for KmuNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("KmuNs").finish()
    }
}
#[doc = "Key management unit 0"]
pub mod kmu_ns;
#[doc = "Non-volatile memory controller 0"]
pub struct NvmcNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for NvmcNs {}
impl NvmcNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const nvmc_ns::RegisterBlock = 0x4003_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const nvmc_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for NvmcNs {
    type Target = nvmc_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for NvmcNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("NvmcNs").finish()
    }
}
#[doc = "Non-volatile memory controller 0"]
pub mod nvmc_ns;
#[doc = "Access Port Protection 1"]
pub struct ApprotectS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ApprotectS {}
impl ApprotectS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const approtect_ns::RegisterBlock = 0x5003_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const approtect_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for ApprotectS {
    type Target = approtect_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ApprotectS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ApprotectS").finish()
    }
}
#[doc = "Access Port Protection 1"]
pub use self::approtect_ns as approtect_s;
#[doc = "Key management unit 1"]
pub struct KmuS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for KmuS {}
impl KmuS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const kmu_ns::RegisterBlock = 0x5003_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const kmu_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for KmuS {
    type Target = kmu_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for KmuS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("KmuS").finish()
    }
}
#[doc = "Key management unit 1"]
pub use self::kmu_ns as kmu_s;
#[doc = "Non-volatile memory controller 1"]
pub struct NvmcS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for NvmcS {}
impl NvmcS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const nvmc_ns::RegisterBlock = 0x5003_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const nvmc_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for NvmcS {
    type Target = nvmc_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for NvmcS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("NvmcS").finish()
    }
}
#[doc = "Non-volatile memory controller 1"]
pub use self::nvmc_ns as nvmc_s;
#[doc = "Volatile Memory controller 0"]
pub struct VmcNs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for VmcNs {}
impl VmcNs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vmc_ns::RegisterBlock = 0x4003_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vmc_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for VmcNs {
    type Target = vmc_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for VmcNs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("VmcNs").finish()
    }
}
#[doc = "Volatile Memory controller 0"]
pub mod vmc_ns;
#[doc = "Volatile Memory controller 1"]
pub struct VmcS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for VmcS {}
impl VmcS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const vmc_ns::RegisterBlock = 0x5003_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const vmc_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for VmcS {
    type Target = vmc_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for VmcS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("VmcS").finish()
    }
}
#[doc = "Volatile Memory controller 1"]
pub use self::vmc_ns as vmc_s;
#[doc = "CRYPTOCELL HOST_RGF interface"]
pub struct CcHostRgfS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CcHostRgfS {}
impl CcHostRgfS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cc_host_rgf_s::RegisterBlock = 0x5084_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cc_host_rgf_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CcHostRgfS {
    type Target = cc_host_rgf_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CcHostRgfS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CcHostRgfS").finish()
    }
}
#[doc = "CRYPTOCELL HOST_RGF interface"]
pub mod cc_host_rgf_s;
#[doc = "ARM TrustZone CryptoCell register interface"]
pub struct CryptocellS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CryptocellS {}
impl CryptocellS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cryptocell_s::RegisterBlock = 0x5084_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cryptocell_s::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CryptocellS {
    type Target = cryptocell_s::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CryptocellS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CryptocellS").finish()
    }
}
#[doc = "ARM TrustZone CryptoCell register interface"]
pub mod cryptocell_s;
#[doc = "GPIO Port 0"]
pub struct P0Ns {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for P0Ns {}
impl P0Ns {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const p0_ns::RegisterBlock = 0x4084_2500 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const p0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for P0Ns {
    type Target = p0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for P0Ns {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("P0Ns").finish()
    }
}
#[doc = "GPIO Port 0"]
pub mod p0_ns;
#[doc = "GPIO Port 1"]
pub struct P0S {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for P0S {}
impl P0S {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const p0_ns::RegisterBlock = 0x5084_2500 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const p0_ns::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for P0S {
    type Target = p0_ns::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for P0S {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("P0S").finish()
    }
}
#[doc = "GPIO Port 1"]
pub use self::p0_ns as p0_s;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "FICR_S"]
    pub ficr_s: FicrS,
    #[doc = "UICR_S"]
    pub uicr_s: UicrS,
    #[doc = "TAD_S"]
    pub tad_s: TadS,
    #[doc = "SPU_S"]
    pub spu_s: SpuS,
    #[doc = "REGULATORS_NS"]
    pub regulators_ns: RegulatorsNs,
    #[doc = "REGULATORS_S"]
    pub regulators_s: RegulatorsS,
    #[doc = "CLOCK_NS"]
    pub clock_ns: ClockNs,
    #[doc = "POWER_NS"]
    pub power_ns: PowerNs,
    #[doc = "CLOCK_S"]
    pub clock_s: ClockS,
    #[doc = "POWER_S"]
    pub power_s: PowerS,
    #[doc = "CTRL_AP_PERI_S"]
    pub ctrl_ap_peri_s: CtrlApPeriS,
    #[doc = "SPIM0_NS"]
    pub spim0_ns: Spim0Ns,
    #[doc = "SPIS0_NS"]
    pub spis0_ns: Spis0Ns,
    #[doc = "TWIM0_NS"]
    pub twim0_ns: Twim0Ns,
    #[doc = "TWIS0_NS"]
    pub twis0_ns: Twis0Ns,
    #[doc = "UARTE0_NS"]
    pub uarte0_ns: Uarte0Ns,
    #[doc = "SPIM0_S"]
    pub spim0_s: Spim0S,
    #[doc = "SPIS0_S"]
    pub spis0_s: Spis0S,
    #[doc = "TWIM0_S"]
    pub twim0_s: Twim0S,
    #[doc = "TWIS0_S"]
    pub twis0_s: Twis0S,
    #[doc = "UARTE0_S"]
    pub uarte0_s: Uarte0S,
    #[doc = "SPIM1_NS"]
    pub spim1_ns: Spim1Ns,
    #[doc = "SPIS1_NS"]
    pub spis1_ns: Spis1Ns,
    #[doc = "TWIM1_NS"]
    pub twim1_ns: Twim1Ns,
    #[doc = "TWIS1_NS"]
    pub twis1_ns: Twis1Ns,
    #[doc = "UARTE1_NS"]
    pub uarte1_ns: Uarte1Ns,
    #[doc = "SPIM1_S"]
    pub spim1_s: Spim1S,
    #[doc = "SPIS1_S"]
    pub spis1_s: Spis1S,
    #[doc = "TWIM1_S"]
    pub twim1_s: Twim1S,
    #[doc = "TWIS1_S"]
    pub twis1_s: Twis1S,
    #[doc = "UARTE1_S"]
    pub uarte1_s: Uarte1S,
    #[doc = "SPIM2_NS"]
    pub spim2_ns: Spim2Ns,
    #[doc = "SPIS2_NS"]
    pub spis2_ns: Spis2Ns,
    #[doc = "TWIM2_NS"]
    pub twim2_ns: Twim2Ns,
    #[doc = "TWIS2_NS"]
    pub twis2_ns: Twis2Ns,
    #[doc = "UARTE2_NS"]
    pub uarte2_ns: Uarte2Ns,
    #[doc = "SPIM2_S"]
    pub spim2_s: Spim2S,
    #[doc = "SPIS2_S"]
    pub spis2_s: Spis2S,
    #[doc = "TWIM2_S"]
    pub twim2_s: Twim2S,
    #[doc = "TWIS2_S"]
    pub twis2_s: Twis2S,
    #[doc = "UARTE2_S"]
    pub uarte2_s: Uarte2S,
    #[doc = "SPIM3_NS"]
    pub spim3_ns: Spim3Ns,
    #[doc = "SPIS3_NS"]
    pub spis3_ns: Spis3Ns,
    #[doc = "TWIM3_NS"]
    pub twim3_ns: Twim3Ns,
    #[doc = "TWIS3_NS"]
    pub twis3_ns: Twis3Ns,
    #[doc = "UARTE3_NS"]
    pub uarte3_ns: Uarte3Ns,
    #[doc = "SPIM3_S"]
    pub spim3_s: Spim3S,
    #[doc = "SPIS3_S"]
    pub spis3_s: Spis3S,
    #[doc = "TWIM3_S"]
    pub twim3_s: Twim3S,
    #[doc = "TWIS3_S"]
    pub twis3_s: Twis3S,
    #[doc = "UARTE3_S"]
    pub uarte3_s: Uarte3S,
    #[doc = "GPIOTE0_S"]
    pub gpiote0_s: Gpiote0S,
    #[doc = "SAADC_NS"]
    pub saadc_ns: SaadcNs,
    #[doc = "SAADC_S"]
    pub saadc_s: SaadcS,
    #[doc = "TIMER0_NS"]
    pub timer0_ns: Timer0Ns,
    #[doc = "TIMER0_S"]
    pub timer0_s: Timer0S,
    #[doc = "TIMER1_NS"]
    pub timer1_ns: Timer1Ns,
    #[doc = "TIMER1_S"]
    pub timer1_s: Timer1S,
    #[doc = "TIMER2_NS"]
    pub timer2_ns: Timer2Ns,
    #[doc = "TIMER2_S"]
    pub timer2_s: Timer2S,
    #[doc = "RTC0_NS"]
    pub rtc0_ns: Rtc0Ns,
    #[doc = "RTC0_S"]
    pub rtc0_s: Rtc0S,
    #[doc = "RTC1_NS"]
    pub rtc1_ns: Rtc1Ns,
    #[doc = "RTC1_S"]
    pub rtc1_s: Rtc1S,
    #[doc = "DPPIC_NS"]
    pub dppic_ns: DppicNs,
    #[doc = "DPPIC_S"]
    pub dppic_s: DppicS,
    #[doc = "WDT_NS"]
    pub wdt_ns: WdtNs,
    #[doc = "WDT_S"]
    pub wdt_s: WdtS,
    #[doc = "EGU0_NS"]
    pub egu0_ns: Egu0Ns,
    #[doc = "EGU0_S"]
    pub egu0_s: Egu0S,
    #[doc = "EGU1_NS"]
    pub egu1_ns: Egu1Ns,
    #[doc = "EGU1_S"]
    pub egu1_s: Egu1S,
    #[doc = "EGU2_NS"]
    pub egu2_ns: Egu2Ns,
    #[doc = "EGU2_S"]
    pub egu2_s: Egu2S,
    #[doc = "EGU3_NS"]
    pub egu3_ns: Egu3Ns,
    #[doc = "EGU3_S"]
    pub egu3_s: Egu3S,
    #[doc = "EGU4_NS"]
    pub egu4_ns: Egu4Ns,
    #[doc = "EGU4_S"]
    pub egu4_s: Egu4S,
    #[doc = "EGU5_NS"]
    pub egu5_ns: Egu5Ns,
    #[doc = "EGU5_S"]
    pub egu5_s: Egu5S,
    #[doc = "PWM0_NS"]
    pub pwm0_ns: Pwm0Ns,
    #[doc = "PWM0_S"]
    pub pwm0_s: Pwm0S,
    #[doc = "PWM1_NS"]
    pub pwm1_ns: Pwm1Ns,
    #[doc = "PWM1_S"]
    pub pwm1_s: Pwm1S,
    #[doc = "PWM2_NS"]
    pub pwm2_ns: Pwm2Ns,
    #[doc = "PWM2_S"]
    pub pwm2_s: Pwm2S,
    #[doc = "PWM3_NS"]
    pub pwm3_ns: Pwm3Ns,
    #[doc = "PWM3_S"]
    pub pwm3_s: Pwm3S,
    #[doc = "PDM_NS"]
    pub pdm_ns: PdmNs,
    #[doc = "PDM_S"]
    pub pdm_s: PdmS,
    #[doc = "I2S_NS"]
    pub i2s_ns: I2sNs,
    #[doc = "I2S_S"]
    pub i2s_s: I2sS,
    #[doc = "IPC_NS"]
    pub ipc_ns: IpcNs,
    #[doc = "IPC_S"]
    pub ipc_s: IpcS,
    #[doc = "FPU_NS"]
    pub fpu_ns: FpuNs,
    #[doc = "GPIOTE1_NS"]
    pub gpiote1_ns: Gpiote1Ns,
    #[doc = "APPROTECT_NS"]
    pub approtect_ns: ApprotectNs,
    #[doc = "KMU_NS"]
    pub kmu_ns: KmuNs,
    #[doc = "NVMC_NS"]
    pub nvmc_ns: NvmcNs,
    #[doc = "APPROTECT_S"]
    pub approtect_s: ApprotectS,
    #[doc = "KMU_S"]
    pub kmu_s: KmuS,
    #[doc = "NVMC_S"]
    pub nvmc_s: NvmcS,
    #[doc = "VMC_NS"]
    pub vmc_ns: VmcNs,
    #[doc = "VMC_S"]
    pub vmc_s: VmcS,
    #[doc = "CC_HOST_RGF_S"]
    pub cc_host_rgf_s: CcHostRgfS,
    #[doc = "CRYPTOCELL_S"]
    pub cryptocell_s: CryptocellS,
    #[doc = "P0_NS"]
    pub p0_ns: P0Ns,
    #[doc = "P0_S"]
    pub p0_s: P0S,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            ficr_s: FicrS {
                _marker: PhantomData,
            },
            uicr_s: UicrS {
                _marker: PhantomData,
            },
            tad_s: TadS {
                _marker: PhantomData,
            },
            spu_s: SpuS {
                _marker: PhantomData,
            },
            regulators_ns: RegulatorsNs {
                _marker: PhantomData,
            },
            regulators_s: RegulatorsS {
                _marker: PhantomData,
            },
            clock_ns: ClockNs {
                _marker: PhantomData,
            },
            power_ns: PowerNs {
                _marker: PhantomData,
            },
            clock_s: ClockS {
                _marker: PhantomData,
            },
            power_s: PowerS {
                _marker: PhantomData,
            },
            ctrl_ap_peri_s: CtrlApPeriS {
                _marker: PhantomData,
            },
            spim0_ns: Spim0Ns {
                _marker: PhantomData,
            },
            spis0_ns: Spis0Ns {
                _marker: PhantomData,
            },
            twim0_ns: Twim0Ns {
                _marker: PhantomData,
            },
            twis0_ns: Twis0Ns {
                _marker: PhantomData,
            },
            uarte0_ns: Uarte0Ns {
                _marker: PhantomData,
            },
            spim0_s: Spim0S {
                _marker: PhantomData,
            },
            spis0_s: Spis0S {
                _marker: PhantomData,
            },
            twim0_s: Twim0S {
                _marker: PhantomData,
            },
            twis0_s: Twis0S {
                _marker: PhantomData,
            },
            uarte0_s: Uarte0S {
                _marker: PhantomData,
            },
            spim1_ns: Spim1Ns {
                _marker: PhantomData,
            },
            spis1_ns: Spis1Ns {
                _marker: PhantomData,
            },
            twim1_ns: Twim1Ns {
                _marker: PhantomData,
            },
            twis1_ns: Twis1Ns {
                _marker: PhantomData,
            },
            uarte1_ns: Uarte1Ns {
                _marker: PhantomData,
            },
            spim1_s: Spim1S {
                _marker: PhantomData,
            },
            spis1_s: Spis1S {
                _marker: PhantomData,
            },
            twim1_s: Twim1S {
                _marker: PhantomData,
            },
            twis1_s: Twis1S {
                _marker: PhantomData,
            },
            uarte1_s: Uarte1S {
                _marker: PhantomData,
            },
            spim2_ns: Spim2Ns {
                _marker: PhantomData,
            },
            spis2_ns: Spis2Ns {
                _marker: PhantomData,
            },
            twim2_ns: Twim2Ns {
                _marker: PhantomData,
            },
            twis2_ns: Twis2Ns {
                _marker: PhantomData,
            },
            uarte2_ns: Uarte2Ns {
                _marker: PhantomData,
            },
            spim2_s: Spim2S {
                _marker: PhantomData,
            },
            spis2_s: Spis2S {
                _marker: PhantomData,
            },
            twim2_s: Twim2S {
                _marker: PhantomData,
            },
            twis2_s: Twis2S {
                _marker: PhantomData,
            },
            uarte2_s: Uarte2S {
                _marker: PhantomData,
            },
            spim3_ns: Spim3Ns {
                _marker: PhantomData,
            },
            spis3_ns: Spis3Ns {
                _marker: PhantomData,
            },
            twim3_ns: Twim3Ns {
                _marker: PhantomData,
            },
            twis3_ns: Twis3Ns {
                _marker: PhantomData,
            },
            uarte3_ns: Uarte3Ns {
                _marker: PhantomData,
            },
            spim3_s: Spim3S {
                _marker: PhantomData,
            },
            spis3_s: Spis3S {
                _marker: PhantomData,
            },
            twim3_s: Twim3S {
                _marker: PhantomData,
            },
            twis3_s: Twis3S {
                _marker: PhantomData,
            },
            uarte3_s: Uarte3S {
                _marker: PhantomData,
            },
            gpiote0_s: Gpiote0S {
                _marker: PhantomData,
            },
            saadc_ns: SaadcNs {
                _marker: PhantomData,
            },
            saadc_s: SaadcS {
                _marker: PhantomData,
            },
            timer0_ns: Timer0Ns {
                _marker: PhantomData,
            },
            timer0_s: Timer0S {
                _marker: PhantomData,
            },
            timer1_ns: Timer1Ns {
                _marker: PhantomData,
            },
            timer1_s: Timer1S {
                _marker: PhantomData,
            },
            timer2_ns: Timer2Ns {
                _marker: PhantomData,
            },
            timer2_s: Timer2S {
                _marker: PhantomData,
            },
            rtc0_ns: Rtc0Ns {
                _marker: PhantomData,
            },
            rtc0_s: Rtc0S {
                _marker: PhantomData,
            },
            rtc1_ns: Rtc1Ns {
                _marker: PhantomData,
            },
            rtc1_s: Rtc1S {
                _marker: PhantomData,
            },
            dppic_ns: DppicNs {
                _marker: PhantomData,
            },
            dppic_s: DppicS {
                _marker: PhantomData,
            },
            wdt_ns: WdtNs {
                _marker: PhantomData,
            },
            wdt_s: WdtS {
                _marker: PhantomData,
            },
            egu0_ns: Egu0Ns {
                _marker: PhantomData,
            },
            egu0_s: Egu0S {
                _marker: PhantomData,
            },
            egu1_ns: Egu1Ns {
                _marker: PhantomData,
            },
            egu1_s: Egu1S {
                _marker: PhantomData,
            },
            egu2_ns: Egu2Ns {
                _marker: PhantomData,
            },
            egu2_s: Egu2S {
                _marker: PhantomData,
            },
            egu3_ns: Egu3Ns {
                _marker: PhantomData,
            },
            egu3_s: Egu3S {
                _marker: PhantomData,
            },
            egu4_ns: Egu4Ns {
                _marker: PhantomData,
            },
            egu4_s: Egu4S {
                _marker: PhantomData,
            },
            egu5_ns: Egu5Ns {
                _marker: PhantomData,
            },
            egu5_s: Egu5S {
                _marker: PhantomData,
            },
            pwm0_ns: Pwm0Ns {
                _marker: PhantomData,
            },
            pwm0_s: Pwm0S {
                _marker: PhantomData,
            },
            pwm1_ns: Pwm1Ns {
                _marker: PhantomData,
            },
            pwm1_s: Pwm1S {
                _marker: PhantomData,
            },
            pwm2_ns: Pwm2Ns {
                _marker: PhantomData,
            },
            pwm2_s: Pwm2S {
                _marker: PhantomData,
            },
            pwm3_ns: Pwm3Ns {
                _marker: PhantomData,
            },
            pwm3_s: Pwm3S {
                _marker: PhantomData,
            },
            pdm_ns: PdmNs {
                _marker: PhantomData,
            },
            pdm_s: PdmS {
                _marker: PhantomData,
            },
            i2s_ns: I2sNs {
                _marker: PhantomData,
            },
            i2s_s: I2sS {
                _marker: PhantomData,
            },
            ipc_ns: IpcNs {
                _marker: PhantomData,
            },
            ipc_s: IpcS {
                _marker: PhantomData,
            },
            fpu_ns: FpuNs {
                _marker: PhantomData,
            },
            gpiote1_ns: Gpiote1Ns {
                _marker: PhantomData,
            },
            approtect_ns: ApprotectNs {
                _marker: PhantomData,
            },
            kmu_ns: KmuNs {
                _marker: PhantomData,
            },
            nvmc_ns: NvmcNs {
                _marker: PhantomData,
            },
            approtect_s: ApprotectS {
                _marker: PhantomData,
            },
            kmu_s: KmuS {
                _marker: PhantomData,
            },
            nvmc_s: NvmcS {
                _marker: PhantomData,
            },
            vmc_ns: VmcNs {
                _marker: PhantomData,
            },
            vmc_s: VmcS {
                _marker: PhantomData,
            },
            cc_host_rgf_s: CcHostRgfS {
                _marker: PhantomData,
            },
            cryptocell_s: CryptocellS {
                _marker: PhantomData,
            },
            p0_ns: P0Ns {
                _marker: PhantomData,
            },
            p0_s: P0S {
                _marker: PhantomData,
            },
        }
    }
}
